[Duck]
quack()
swim()
display()
//기타 오리 관련 메소드

[MallardDuck] ext Duck
display()

[RedheadDuck] ext Duck
display()

[RubberDuck] ext Duck
quack() {//아무것도 하지 않도록 오버라이드}
display() {//가짜 오리}
fly() {//아무것도 하지 않도록 오버라이드}

오리가 날 수 있어야 한다.
[Duck]에 fly() 추가
=> 상속받은 모든 오리들이 날아다닌다!

∴ 상속은 옳은 방법이 아니다!!

* 아이디어1. 인터페이스는?
[Flyable]
fly()

[Quackable]
quack()

=> [MallardDuck] imp Flyable, Quackable
=> [RedheadDuck] imp Flyable, Quackable
=> [RubberDuck] imp Flyable, Quackable
... 인터페이스에는 구현된 코드가 없으므로 코드를 재사용할 수 없다
... 행동을 바꿀 때마다 그 행동이 정의되어 있는 서로 다른 서브클래스를 전부 찾아서 코드를 일일이 고쳐야 한다.

"바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는 영향을 끼치지 않고 그 부분만 고치거나 확장할 수 있다."

[Duck]에서 바뀌는 부분인 fly()와 quack()을 다른 클래스 집합으로 구현한다.

[FlyBehavior] 
[FlyWithWings] imp fly() { //나는 방법을 구현 }
[FlyNoWay] imp fly() { //아무것도 하지 않음 }

////////////////////////////////////////////////
"상위 형식에 맞춰서 프로그래밍한다"
Dog d = new Dog();
d.bark();

=> 인터페이스와 상위 형식에 맞춰서 프로그래밍 한다.
Animal animal = new Dog();
animal.makeSound();

=> 상위 형식의 인스턴스를 만드는 과정을 직접 코드로 만드는 대신 구체적으로 구현된 객체를 실행 시에 대입하는 것
a = getAnimal();
a.makeSound();
//////////////////////////////////////////////////

I[FlyBehavior] fly()
C[FlyWithWings] imp [FlyBehavior]
C[FlyNoWay] imp [FlyBehavior]

I[QuackBehavior] quack()
C[Quack] imp I[QuackBehavior]
C[Sqeak] imp I[QuackBehavior]
C[MuteQuack] imp I[QuackBehavior]

※ 나는 행동과 꽥꽥거리는 행동을 Duck클래스(또는 그 서브클래스)에서 정의한 메소드를 써서 구현하지 않고
다른 클래스에 위임한다

[Duck]
FlyBehavior FlyBehavior
QuackBehavior quackBehavior
performQuack() //quack() 였던 것
performFly() //fly() 였던 것

=> 구현
public abstract class Duck {
    QuackBehavior quackBehavior;
    //기타 코드

    public void performQuack() {
        quackBehavior.quack(); //직접 처리하는 대신, quackBehavior로 참조되는 객체에 그 행동을 위임한다.
    }
}

public class MallardDuck extends Duck {

    public MallardDuck() {
        quackBehavior = new Quack(); //다형성. Quack 객체에게 위임됨.
        FlyBehavior = new FlyWithWings(); //다형성. FlyWithWings에게 위임됨.
    }

    public void display() {
        System.out.println("저는 물오리입니다.);
    }
}

